This chapter presents an overview of contributions in the area of engineering \ac{BDI} \ac{MAS} targeting the goal outlined in \ref{rq:5} of making \ac{BDI} \ac{MAS} engineering more accessible for developers wishing to integrate \ac{BDI} agents into larger software systems, there including \acp{DTE} and more broadly Web-based systems.
%
Additionally, the chapter explores the role of \emph{explainability} in \ac{BDI} agents, to make agent behavior more transparent to users, as this is a key requirement for intelligent applications applied to critical domains such as healthcare (\Cref{sec:back:h40:explainable-ai}).


%=======================================================
\section{\acs{BDI} Agents in \aclp{DTE}}
\label{sec:mas:engineering:bdi-dt}
%=======================================================

The previous chapter presented a general alignment between the abstractions of autonomous agents and \acp{DT},
highlighting the complementary nature of the two paradigms, and the potential benefits of their integration.
%
This section explores how \ac{BDI} agents,
as a specific subset of autonomous agents,
can be relevant in the context of \acp{DT} in general,
and specifically in relationship with the proposal of this thesis of \acp{DTE} and their implementation as hypermedia systems.

The specific application of \ac{BDI} agents is considered in this thesis alongside three main aspects: 
\begin{itemize}
    
    \item \textbf{Controllability of Autonomous Behavior}:
    \ac{BDI} agents belong to the class of \emph{programmed} agents
    and have been historically tied to the design of programming languages and frameworks,
    that allow developers to specify and implement agent behavior which could exhibit a degree of autonomy,
    interpreted as ability to adapt such behavior depending on contextual information.
    This makes \ac{BDI} agents particularly suitable for scenarios where
    developers need to encode business processes and domain logic 
    in a clear and controllable manner. 
    
    \item \textbf{Expressiveness of Cognitive Abstractions}:
    \ac{BDI} agents provide high-level cognitive abstractions to encode autonomous behavior.
    The declarative nature of \ac{BDI} specifications allows developers to focus on defining system-level goals
    and strategies to achieve them explicitly, rather than detailing low-level control flows.
    \ac{BDI} agents further reason on an explicit semantic model in form of beliefs, that can encode knowledge about a specific domain
    and encapsulate contextual information relevant to the agent's operation.
    
    \item \textbf{Explainability of Agent Behavior}:
    \ac{BDI} agents offer inherent explainability features,
    as their internal state and decision-making processes are explicitly represented through beliefs, desires, and intentions
    which can be inspected and queried.
    This transparency is crucial in applications where understanding the rationale behind agent actions is important for user trust and system validation.

\end{itemize}

These features make \ac{BDI} agents a compelling choice for implementing autonomous components within the context of \acp{DTE}.
%
Namely, this thesis studies and contributes to the engineering of \ac{BDI} \ac{MAS} envisioning their application in two main scenarios, outlined in the following.

\paragraph{\ac{BDI} Agents for \emph{Cognitive} \aclp{DT}:}
\Cref{sec:back:dt:ai} introduced the concept of \emph{cognitive} \acp{DT} as a specific class of \acp{DT} that leverage \ac{AI} techniques to enhance their ability to autonomously and proactively adapt to changes in the physical counterpart in a goal-driven fashion.
%
This thesis envisions \ac{BDI} agents as a suitable technology to implement such autonomous components within cognitive \acp{DT}, through the mechanism of \emph{augmentation} outlined in \Cref{sec:dte:engineering-dt:dt-augmentation}.
%
This would effectively implement the micro-architecture \textbf{(E)} presented in \Cref{sec:mas+dt:patterns}.
%
In this context, \ac{BDI} agents can encapsulate the cognitive capabilities of the \ac{DT}, and be encapsulated as an asynchronous augmentation function within a \ac{DT}, that can access the \ac{DT} state, observe its evolution over time, and suggest actions to adapt the \ac{DT} behavior. 
%
To this end, the features of \ac{BDI} agents outlined above, are particularly relevant:
\begin{inlinelist}
\item \emph{controllability} is necessary to ensure that the autonomous behavior is aligned with the domain requirements and constraints;
\item \emph{cognitive abstractions} can be an effective way to interact with the structured and semantic-rich model of the \ac{DT} digital representation;
\item \emph{explainability} is crucial to audit and understand the decisions made by the autonomous components within the \ac{DT}.
\end{inlinelist}

\paragraph{\ac{BDI} Agents as consumers of the \acl{HWoDT}:}
In the original vision of the \ac{WoDT}, software agents were considered as primary consumers of the \ac{WoDT} digital representation, leveraging its structured and semantic-rich model to reason about the physical counterpart and make decisions accordingly~\cite{web-of-dt-ricci-2022}
%
This aligns with the \ac{HWoDT} proposed in this thesis, that can serve as a shared hypermedia environment for \ac{MAS} that follow the vision of \ac{hMAS} introduced in \Cref{sec:back:mas:web}.
%
\acp{DT} can serve the purpose of simplifying the interaction of agents with the physical world, and enhance the reasoning capabilities of agents by providing rich models of the \ac{PA} that can be used also to simulate possible future states hence allowing an agent to perform \emph{what-if} analysis of its actions~\cite{DBLP:conf/eumas/Burattini23}.
%
Micro-architecture \textbf{(A)} presented in \Cref{sec:mas+dt:patterns} envisions agents interacting with \acp{DT} following this pattern.
%
When scaling to ecosystems, the \ac{HWoDT} provides a set of high-level interaction mechanisms that can be exploited by agents to interact with the whole set of \acp{DT} in a uniform manner.
%
\ac{BDI} agents can be particularly suitable for this scenario to encode business logic that spans multiple \acp{DT}, such as coordinating the behavior of different \acp{DT}, or implementing complex workflows that involve interactions among multiple \acp{DT}.
%
In this context, the features of \ac{BDI} agents outlined above are again particularly relevant:
\begin{inlinelist}
\item \emph{controllability} is necessary as the interactions of multiple \acp{DT} must be predictable; 
\item \emph{cognitive abstractions} can help in reasoning about complex interactions among multiple \acp{DT} and express clear system-level goals;
\item \emph{explainability} is crucial to audit and understand the decisions made by agents, especially when they interact with multiple \acp{DT} and potentially affect critical operations.
\end{inlinelist}

\medskip

The integration of \ac{BDI} agents within \acp{DTE} with the goals and strategy outlined above is a long-term research direction of this thesis, especially relevant for the domain of healthcare, in which the automation of complex processes involving autonomous agents is seen as a major opportunity to enhance the quality of care and reduce costs~\cite{Croatti_Gabellini_Montagna_Ricci_2020}.
%
Accordingly, the rest of this chapter focuses on short-term actions aimed at enhancing the engineering of \ac{BDI} \ac{MAS} in general, 
with actions tailored to achieve a more robust engineering process, as well as facilitate their integration with external systems such as \acp{DTE} in the future.
%
The potential integration of \ac{BDI} agents with \acp{DTE} further opens up interesting perspectives on how to better align the knowledge representation of \ac{BDI} agents with the semantic models used in \acp{DT}, how to enhance adaptability in dynamic environments such as the \ac{HWoDT}, including enhancing \ac{BDI} agents with future-oriented reasoning capabilities that may leverage the simulation capabilities of \acp{DT}, and, finally, how to enhance the explainability of \ac{BDI} agents so that the autonomous behavior is transparent to both system developers and end-users.

%=======================================================
\section{Tooling for \acs{BDI} Agent Programming}
\label{sec:mas:engineering:jakta}
%=======================================================

\ac{BDI}~\cite{rao1991modeling} agents are considered
an excellent tool for modelling autonomous or intelligent entities
via high-level \emph{cognitive} abstractions.
%
Therefore, in the early 2000s, the expectation of the community was for \ac{AOP}~\cite{Shoham_1993} to gain its spot among other prominent paradigms,
such as object-oriented (\acs{OOP}), functional (\acs{FP}), imperative (\acs{IP}), and logic (\acs{LP}) programming.

However,
a few decades later,
it can be observed that,
although \ac{BDI} has deeply impacted the research field of \ac{MAS} and \ac{AI},
it still fails at reaching mainstream programming,
even in contexts where the application scenario would make it
a good choice to design autonomous behavior.

Limited adoption of \ac{BDI} in mainstream programming has been widely discussed~\cite{lind2000aose,DBLP:journals/sigsoft/MascardiWR19,DBLP:journals/ijaose/DignumD10,DBLP:books/sp/14/Muller014,DBLP:journals/corr/abs-1209-1428}, with no consensus on the root causes.
%
Some argue that improved tooling is needed~\cite{DBLP:conf/dalt/Hindriks14},
while others suggest that the main barrier is the cost of learning a new paradigm~\cite{DBLP:journals/ijaose/Logan18} without the gain of significant benefits in terms of engineering complex behavior, claiming that new features are needed to make \ac{BDI} more appealing.

These perspectives are not necessarily conflicting, but rather arguably complementary: paradigm adoption depends on both effective abstractions and supportive tools.
%
In \cite{DBLP:journals/ijaose/Logan18} \cpp is mentioned as an example of language that despite little tooling support at its inception, gained popularity thanks to the introduction of new abstractions (e.g., classes) that made it more appealing to mainstream developers.
%
It could be argued that it was the seamless, gradual integration of such new abstractions into existing \ac{IP} practices that made \cpp successful.
%
As seen in the evolution of \cpp and Java, such gradual integration of new abstractions can lower adoption barriers and foster community-driven innovation.
%
Thus, paradigm and tooling evolution should proceed in parallel to facilitate broader adoption, possibly by integrating \ac{BDI} concepts into existing mainstream programming practices, paradigms, software ecosystems, and tools.

%-------------------------------------------------------
\subsection{State of the Art}
%-------------------------------------------------------

Several open-source, publicly available, and actively maintained\footnote{Following the definition in~\cite{Cardoso_Ferrando_2021}.} frameworks exist for \ac{BDI} \ac{AOP} programming.
This section highlights representative frameworks, based on recent surveys of logic-based agent-oriented technologies~\cite{lptech4mas-jaamas35} and agent-based programming for \ac{MAS}~\cite{Cardoso_Ferrando_2021}.

\Cref{tab:frameworks} summarizes key characteristic of selected frameworks.
%
Other notable actively developed frameworks that did not meet the selection criteria but still deserve mention are
\jack{}~\cite{Winikoff2005} (not open-source),
the aforementioned \jacamo{}~\cite{Boissier_Bordini_Hübner_Ricci_Santi_2013} frameworks which extends \jason{} (\Cref{sec:back:mas:aose}),
\sarl{}~\cite{iat2014sarl} (not \ac{BDI}-specific),
and \goal{}~\cite{Hindriks2009} (not \ac{BDI}-adhering).

This short overview highlights how existing frameworks differ in terms of intended target applications, execution platforms and agent programming syntax.
%
A more in-depth analysis of the state-of-the-art frameworks is presented in \cite{DBLP:journals/sncs/BaiardiBCP24}, 
focusing on their features and limitations.
%
From this analysis, it is possible to observe that
most frameworks are build with custom \ac{DSL} syntaxes that require learning new languages, as well as dedicated supporting tools (e.g., IDE plugins) that require additional effort to set up and maintain.
%
This also hinders integration with existing software ecosystems and tools, as well as reuse of existing libraries and components, as the mechanisms to interface with external code are often limited and not always straightforward to use, requiring developers to shift their mindset away from familiar programming practices.

\begin{table}
    \centering
    \small
    \resizebox{\textwidth}{!}{
    \begin{tabular}{r|c|c|c}
        \textbf{Framework } & \textbf{Platform} & \textbf{Syntax} & \textbf{Intended Target} \\\hline\hline
        \textbf{\makecell[r]{\astra~\cite{CollierRL15}} }
        & JVM
        & custom DSL
        & distributed systems
        \\
        \textbf{\makecell[r]{\gwendolen~\cite{dennis2008gwendolen}} } 
        & \makecell[c]{MCAPL~\cite{Dennis2018}}
        & \agentspeak{}-based
        & \ac{BDI} verification
        \\
        \textbf{\makecell[r]{\jadex~\cite{PokahrBL2005}} } 
        & JVM
        & Java + annotations
        & distributed systems
        \\
        \textbf{\makecell[r]{\jason~\cite{Bordini_Hübner_Wooldridge_2007}} } 
        & JVM
        & \agentspeak{}
        & \ac{BDI} research
        \\
        \textbf{\makecell[r]{\jsson~\cite{DBLP:conf/emas/KampikN19}} } 
        & JavaScript
        & JavaScript
        & Web applications
        \\
        \textbf{\makecell[r]{\lightjason~\cite{aschermann2016eumas}} } 
        & JVM
        & \agentspeak{}-based
        & scalable applications
        \\
        \textbf{\makecell[r]{\phidias~\cite{DUrsoLS19}} } 
        & (Micro)Python
        & Python DSL
        & IoT/robotic applications
        \\
        \textbf{\makecell[r]{\spadebdi~\cite{PalancaRCJT22}} } 
        & Python
        & \agentspeak{}
        & distributed systems
        \\
        \hline
        \textbf{\makecell[r]{\jakta~\cite{DBLP:journals/sncs/BaiardiBCP24}} } 
        & JVM*
        & Kotlin DSL
        & general-purpose
        \\
    \end{tabular}
    }
    \normalsize
    \bigskip
    \caption{
        A selection of active \ac{BDI} programming frameworks
        and their respective execution platforms, syntax and intended target.
        \jakta{}, the framework proposed in this section, is included to compare with existing frameworks.
        *\jakta{} is currently implemented on the JVM 
        but could be ported to other platforms thanks to Kotlin's multiplatform capabilities.
    }
    \label{tab:frameworks}
\end{table}


%-------------------------------------------------------
\subsection{Desiderata for Mainstream \acs{BDI} Tooling}
%-------------------------------------------------------

As emerging from the previous section,
the \ac{BDI} \ac{AOP} community has primarily developed toolkits
as libraries, extensions, or entirely custom languages
supported by existing execution platforms.
%
This approach provides a practical environment for prototyping and deployment,
allowing developers to leverage the features of the \emph{host} platform.
%
Hence,
a \ac{BDI} framework typically expects users to work in a top-down manner,
approaching system design as a \ac{MAS} and using \ac{BDI} abstractions to model agents,
while leveraging the host language primarily for implementing vertical, low-level, practical details.

Although this may be effective for \ac{BDI} experts
it may pose a barrier for newcomers.
%
An effective way to learn a new paradigm is to start with a simple yet functional fragment,
then incrementally expand its functionalities,
gradually introducing new concepts and abstractions (example-based learning, see~\cite{vanGog2010}).


Based on these considerations and the analysis of existing frameworks, the following desiderata for mainstream \ac{BDI} tooling are identified:

\paragraph{Interoperability with Mainstream Paradigms:} to have \ac{BDI} work as a \emph{practical} paradigm it is necessary to integrate with external systems that typically are not built using \ac{BDI} concepts, which results in a developer to likely incorporate other paradigms in parts of the developed system.
%
Many modern programming languages (including Kotlin, Python, Scala, etc.) are designed to be \emph{multi-paradigm}, allowing developers to switch among paradigms with relative ease.
%
This approach, known as \emph{paradigm blending},
prioritizes integration of multiple paradigms in one code fragment
over composition of multiple fragments using different paradigms.
%
When paradigms are blended,
the same code fragment may contain \emph{syntactical}
constructs capturing abstractions of diverse paradigms.
%
In this context, \ac{BDI} \ac{AOP} could be envisioned
as yet another paradigm to support,
letting developers free to use a mix of different abstractions in the same codebase.


\paragraph{Code Reuse and Sharing Mechanisms:}

Code reuse is fundamental in software engineering for reducing redundancy and improving maintainability. General-purpose languages support reuse through constructs such as packages, modules, classes, and functions, complemented by import and extension mechanisms.
%
This is important for both \emph{in-project} reuse, but especially for \emph{cross-project} reuse, enabling the creation and sharing of libraries and frameworks. These are usually supported by build automation and dependency management tools that facilitate integration and versioning.
%
In \ac{AOP}, similar mechanisms would enable modularization and reuse of agent specifications. For \ac{BDI} \ac{MAS}, this could involve sharing plans, beliefs, or rules across agents. However, there is no standardized approach for modularity and reuse at the paradigm level.
%
When a framework provides a \ac{FFI}, reuse mechanisms from the host language can be applied to relevant code sections. For example, \jason{} and \spadebdi{} allow internal actions to be defined and reused as Java or Python code, respectively.
%
For code written in the \ac{BDI} language, reuse is often limited to file inclusion (e.g., like in \jason{}). Some like \astra{}, support specification extension, while others, such as \jack{} and \jadex{}, use capabilities~\cite{DBLP:conf/promas/BraubachPL05} to encapsulate reusable components, though interpretations vary.


\paragraph{Development Tools:}
Development tools are critical for effective \ac{BDI} programming.
Modern development environments offer features such as syntax highlighting, code completion, static analysis, and refactoring, which are now expected for a swift development experience.
%
Testing libraries and debugging support are also essential for building reliable systems. However, most \ac{BDI} frameworks lag behind mainstream languages in tool maturity, often due to the high maintenance cost for small communities and limited incentives in tool development in research-driven projects.
%
Developing and maintaining compatibility of plugins for target development environments is challenging.
%
This can be alleviated by developing \emph{internal} \acp{DSL} which can directly leverage existing tools, though sometimes at the expense of language expressiveness.
%
Testing and debugging \acp{MAS} remain complex. \ac{BDI} frameworks offer limited support, and recent efforts~\cite{DBLP:conf/atal/RodriguezTW23,amaral2023atal} are still maturing. Additionally, debugging through host language tools is possible but often exposes low-level details irrelevant to \ac{BDI} abstractions.
%
Simulation is another important tool, especially for distributed systems. Existing \ac{MABS} frameworks are not tailored for \ac{BDI} agents, leading to an abstraction gap and duplicated effort when implementing both production and simulation environments. Ideally, frameworks should facilitate seamless switching between real and simulated deployments as discussed in \Cref{sec:mas:engineering:simulation}

\paragraph{Configurability:}
\ac{BDI} frameworks also manage the runtime environment for agents, including input/output, communication, and concurrency models (\Cref{ssec:mas:engineering:concurrency}). Configurability in these aspects is essential for adapting frameworks to diverse application requirements.
%
The concurrency model, mapping the agent control flow to execution primitives (e.g., threads, processes, event loops), directly impacts efficiency, determinism, and reproducibility and affects system performance. Most frameworks support one or more concurrency models, but few offer user-oriented APIs for easily customizing or selecting the concurrency model.
%
Agent communication is another key aspect, with frameworks differing in their support for local and distributed messaging. Communication typically relies on agent communication languages (ACLs)~\cite{Kone_Shimazu_Nakajima_2000} and underlying network protocols.
%
Pluggable communication mechanisms, using standard protocols, are considered good practice, allowing users to select or extend protocols as needed. However, multi-protocol support and well-documented APIs for communication configuration remain uncommon.
%
Overall, high configurability in concurrency and communication is a desirable property for mainstream \ac{BDI} tooling, enabling broader applicability and easier integration with existing systems.

%-------------------------------------------------------
\subsection{The \jakta{} Framework}
%-------------------------------------------------------

\jakta{} is a new \ac{BDI} programming framework,
aimed at (gradually) addressing the issues discussed in the sections above.
%
\jakta{} is available on GitHub\footnote{\url{https://github.com/jakta-bdi/jakta}}
under a free, open-source, and permissive licence.
%
The main design principles of the tool are \emph{modularity},
\emph{pluggability} and
\emph{paradigm interoperability}.

\jakta{} clearly separates:
\begin{inlinelist}
    \item definition of concepts (e.g., agents, environment, plans, actions),
    \item the logic that rules concepts' behavior (e.g., execution loops, selection functions),
    and
    \item how these are presented to the final user (e.g., syntax, \ac{API}).
\end{inlinelist}
%
Multi-paradigm interoperability is obtained by designing \jakta{} as an internal \ac{DSL} in Kotlin,
thus leveraging Kotlin's multi-paradigm features that already support \ac{OOP}, \ac{FP}, and \ac{IP} styles.

\begin{figure}[tb]
    \centering
    \includegraphics[width=\textwidth]{figures/mas/jakta_modules.pdf}
    \caption{
        The main modules composing the \jakta{} framework and their dependencies.
    }
    \label{fig:jakta-modules}
\end{figure}

The \jakta{} framework is composed of four main modules (\Cref{fig:jakta-modules}), namely:
%
\begin{enumerate}
    \item the \textbf{\ac{BDI} interpreter}, which governs the execution of agents in environments,
    regardless of the particular syntax used to define them;
    \item the \textbf{\ac{DSL}}, which provides a Kotlin syntax to idiomatically define \ac{BDI} \acp{MAS};
    \item the \textbf{concurrency manager}, which regulates runtime, concurrency, and scheduling aspects for
    any system run by the \ac{BDI} interpreter;
    and
    \item the \textbf{\alchemist{} incarnation},
    which bridges the \ac{BDI} interpreter with the \alchemist{}~\cite{PianiniJOS2013} discrete-event simulator.
\end{enumerate}

A detailed description of the \jakta{} syntax is available in \cite{DBLP:journals/sncs/BaiardiBCP24}, for the interested reader.
%
Here some examples of \jakta{} code are reported to showcase the main features of the framework.

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[
    % float,
    basicstyle=\footnotesize\ttfamily,
    linewidth=\linewidth,
    language=Kotlin,
    caption={Overall structure of a \ac{MAS} specification in \jakta{}.},
    %{Entrypoint of \jakta{}, it contains the description of the Environment and Agents involved in the application.},
    label=lst:mas,
]{listings/jakta-examples/mas_dsl.kt}
\end{minipage}
%
Users can define and launch a \jakta{} \ac{MAS} specification using a \texttt{mas} block (\Cref{lst:mas}).
All elements composing the \ac{MAS} are defined within it, including the (initial) set of agents, the environment model and other \ac{MAS} configuration elements.
%
The \texttt{agent} block in \Cref{lst:mas} defines an individual \ac{BDI} agent,
specifying its initial beliefs and goals, as well as the plan library it will use at runtime.
%
The syntax is valid Kotlin code, which implements at the language level features to support the construction of \acp{DSL} (e.g., lambda with receiver, operator overloading, block-like lambdas, etc.) that can be implemented as \emph{type-safe builders}\footnote{\url{https://kotlinlang.org/docs/type-safe-builders.html}}.
%
This makes the \ac{MAS} specification fully supported by existing Kotlin development tools.

\noindent
\begin{minipage}{\linewidth}
\lstinputlisting[
    % float,
    basicstyle=\scriptsize\ttfamily,
    linewidth=\textwidth,
    language=Kotlin,
    caption={Example of paradigm-blending in \jakta{}. The code snippet uses together \ac{OOP}, \ac{FP}, and \ac{IP} constructs to create a \ac{MAS}.},
    label={lst:blending},
]{listings/jakta-examples/blending.kt}
\end{minipage}
%
% Additionally,
The adoption of a multi-paradigm language such as Kotlin
natively exposes \ac{OOP}, \ac{FP}, and \ac{IP} constructs within the \ac{BDI} \ac{DSL}.
This supports a first level of paradigm blending, which allows composing and parametrizing the \ac{MAS} specification with ease.
%
The blending is exemplified in \Cref{lst:blending},
it describes, using \jakta{} syntax,
a toy example defining a \ac{MAS} with ten agents named as the first ten athletes scraped from a web page.
%
The example showcase the combination of the \ac{OOP} paradigm employed for dealing with regular expressions matching and data extraction,
and the \ac{FP} paradigm used to map URLs to athletes names, and finally to \jakta{} agents.

Further paradigm integration can be leveraged when defining actions.
%
In \jakta{}, a valid action is any instance of the \texttt{Action} interface
(more precisely, of one of its specializations \texttt{InternalAction} or \texttt{ExternalAction}),
and can be written in-place directly inside a \texttt{mas} definition,
possibly using \ac{OOP} or \ac{FP} constructs directly in Kotlin.

\jakta{} has an explicit notion of \emph{environment}. The \jakta{} environment is responsible for:
%
\begin{inlinelist}
    \item tracking the agents in the system;
    \item governing each agent's perception by determining which percepts to deliver;
    \item governing each agent's actuation by making external actions available;
    \item governing communication among agents by deciding how messages are delivered;
    \item enabling stigmergic interaction by making the environment's data accessible to agents.
\end{inlinelist}
%
The basic implementation of the environment acting as a shared data container can be extended to implement more complex functionalities, integrate external systems within the \ac{MAS}, and support distributed communication. 


%=======================================================
\section{Testing \acs{MAS} with Simulation}
\label{sec:mas:engineering:simulation}
%=======================================================

Aside from being useful for in-silico studies,
\emph{simulation} may also aid the \emph{development} and \emph{validation}~\cite{uhrmacher_simulation_2002}
of \acp{MAS} intended for real-world deployment.
%
In fact, simulation enables developers to test the behavior of agents
and their dynamics in complex environments ahead of deployment,
while postponing costs, risks, and efforts associated with real-world execution.

The price for such flexibility, however,
is paid in additional development effort:
first and foremost, to model the deployment context in a simulation environment,
and, additionally,
to maintain alignment between the two versions of the \ac{MAS} codebase,
unless the same \ac{MAS} specification can execute \emph{with no changes}
on both real hardware and a simulator of choice.

This is particularly challenging when dealing with \ac{BDI} \acp{MAS}.
There,
the abstraction gap between the high-level cognitive model of \ac{BDI} agents and most simulators~\cite{singh_integrating_2016},
along with the minimal support of \ac{BDI} technologies
for producing \emph{reproducible} simulations of articulated scenarios~\cite{kehoe2016robust}
lead developers to resort to one of the following approaches~\cite{singh_integrating_2016}:
%
\begin{enumerate}
    \item extension of the \ac{BDI} platform with a dedicated simulation engine,
    which requires additional development effort (e.g., \cite{HubnerB09,ricci_exploiting_2020});
    \item construction and maintenance of two parallel codebases
    one for a simulator extended with \ac{BDI} modeling tools (e.g., \cite{sakellariou_enhancing_2008,TaillandierBCAG16,uhrmacher1998agents}) and one for the actual system,
    leading to consistency issues;
    \item integration of the \ac{BDI} platform with a general-purpose simulation engine,
    typically by synchronizing their execution through some form of middleware (e.g., \cite{singh_integrating_2016,davoust_architecture_2020}).
\end{enumerate}

Despite the idea of using simulation to support \ac{MAS} development being not new
there are not many tools that effectively allow one
\emph{
    ``to execute agents as they are and to switch arbitrarily between execution in the real environment and the virtual test environment''
}~\cite{uhrmacher_simulation_2002}.

This section discusses the challenges of decoupling \ac{BDI} agent concurrency when designing \ac{MAS} frameworks, as a necessary step towards enabling the same specification to run both in real concurrent deployments and in discrete-event simulation environments.
%
The proposed integration of \jakta{} with the \alchemist{} simulator explores the mapping of the \ac{BDI} control loop, showing that different granularities are possible, to address the challenge of providing a seamless transition between real and simulated environments for \ac{BDI} \acp{MAS}.

%-------------------------------------------------------
\subsection{Decoupling Concurrency in BDI MAS}
\label{ssec:mas:engineering:concurrency}
%-------------------------------------------------------

The analysis of a selection of technologies from table \Cref{tab:frameworks} presented in \cite{DBLP:conf/emas/BaiardiBCPRO24} suggests that most \ac{BDI} frameworks tightly couple the \ac{BDI} control loop with the underlying \emph{concurrency model}. 
%
This means that the way in which agents are scheduled and executed is often hardcoded into the framework, limiting flexibility and adaptability to different application requirements.

Several concurrency models are possible for \ac{BDI} \ac{MAS}: 
\begin{itemize}
    \item \emph{\ac{1A1T}}: is the most common where each agent runs in a dedicated thread. This model provides true parallelism but can lead to high resource consumption. 
    \item \emph{\ac{AA1T}}: the degenerate case where all agents run in a single thread, leading to sequential execution (e.g. round-robin scheduling), agents do not run in parallel, but the system is lightweight and easier to debug.
    \item \emph{\ac{AA1EL}}: at the conceptual level is similar to \ac{AA1T}, but instead of using threads, it employs an event loop to manage agent execution. This model is efficient and suitable for handling blocking operations in the agent logic.
    \item \emph{\ac{AA1E}}: similarly to \ac{AA1EL} but there is a shared executor allowing for concurrent execution of agents while still benefiting from the efficiency of event-driven programming. Scaling the executor allows for tuning the level of resource usage and parallelism.
\end{itemize}

Decoupling the specification of the adopted concurrency model from the \ac{BDI} control loop allows to select the most appropriate model for different applications.
%
This requires defining clear interfaces between the \ac{BDI} interpreter and the concurrency manager when designing \ac{BDI} frameworks.
%
Each agent control-loop phase (e.g., perception, deliberation, action) should be treated as a task that can be scheduled on a concurrency abstraction.
%
This decoupling can also serve the purpose of switching between real and simulated execution, as the simulator would act as yet another \emph{executor} of \ac{BDI} tasks.

%-------------------------------------------------------
\subsection{Discrete-Event Simulation for BDI}
%-------------------------------------------------------

\ac{DES} is a powerful technique for modeling complex systems, that can support the scheduling of events over simulated time, and advance the simulation clock to when the next event is due.
%
Given the fact that \ac{BDI} agents can be seen as driven by events (e.g., percepts, messages, internal triggers), \ac{DES} appears as a natural fit for simulating \ac{BDI} \acp{MAS}. 
%
\ac{DES} allows for a fine-grained control over the timing and ordering of events, making it possible to accurately model the asynchronous and concurrent nature of agent interactions.

The integration of a \ac{BDI} \ac{MAS} over a \ac{DES} simulator require mapping the \ac{BDI} control loop iterations onto the simulator's event scheduling.
%
Different granularities of mapping are possible, each with its own trade-offs:
\begin{itemize}
\item \emph{\ac{AMA}}: the entire \ac{MAS} advances in lockstep, with all agents performing one iteration of the control loop in a sequential order at every step. This is the coarsest granularity, usually adopted when simulating \ac{BDI} agents for debugging purposes (e.g., \cite{HubnerB09}).
\item \emph{\ac{ACLI}}: each full iteration of the agent's control loop is treated as a single event. Interleave of agent actions is possible, but the agent execution is treated as atomic steps and cannot model the duration of individual phases.
\item \emph{\ac{ACLP}}: each phase of the control loop (perception, deliberation, action) is mapped to separate events. This allows for more detailed modeling of agent behavior and interactions. All possible interleaving are possible, like in a true concurrent system and hence providing the most accurate simulation of real-world execution.
\item \emph{\ac{ABE}}: each event in the \ac{BDI} agent (e.g., perception, message receipt, internal trigger) is mapped to a discrete event in the simulator. This allows for fine-grained simulation but may increase the number of scheduled events significantly, potentially impacting performance of the simulation, while not providing significant benefits over \ac{ACLP} in most scenarios as the behavior of agents encapsulate its internal events.
\end{itemize}

Other than choosing the appropriate granularity for the mapping, switching between real and simulated execution requires careful handling of time management and \emph{external actions} that are invoked on the environment.

In real execution, time can be perceived from the system clock, while in simulation, time is controlled by the simulator.
%
Therefore, agents must be designed to use a time abstraction that can be adapted to both real and simulated contexts.
%
The same goes for randomness, which should be abstracted to allow for reproducible simulations controlled by the same \emph{seed}. 

For what concerns environment actions, modeling the environment is crucial for accurate simulation. 
%
The agent should be decoupled by the specific implementation of the environment, relying on an interface that can be implemented differently for real and simulated contexts.
%
The simulated environment should mimic the behavior of the real environment as closely as possible, including the generation of perceptions, the effects of actions that modify the environment state and the communication mechanisms among agents which may need to be tested for reliability under different conditions. 

The design of \jakta{} has been influenced by these considerations.
%
This made it possible to integrate \jakta{} with the \alchemist{} \ac{DES} simulator~\cite{PianiniJOS2013}.
%
The integration is achieved by letting \alchemist{} schedule the execution of \jakta{} agents by scheduling their control loop iterations and phases with a time distribution.
%


%-------------------------------------------------------
\subsection{Experimental Demonstrator}
%-------------------------------------------------------

The prototype implementation demonstrates the feasibility of the approach, and showcases how different granularities of mapping can lead to different simulation behaviors with the same \ac{MAS} specification.

To exemplify this, a simple \ac{MAS} is defined to simulate a leader \ac{UAV} moving in a circular path, while other \acp{UAV}
must follow its movement retaining their formation around the leader.

\Cref{fig:code} shows code extracts from the scenario implementation, demonstrating that agent logic is reusable across different execution platforms.

\begin{figure}[tb]
    \begin{minipage}[b]{.6\linewidth}
        \centering
        \lstinputlisting[
            nolol,
            language=Kotlin,
            linewidth=\linewidth,
            basicstyle=\scriptsize\ttfamily,
            label={lst:logic},
    %        caption={Platform-agnostic code}
        ]{listings/jakta+alchemist/agentsLogic.kt}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{.34\linewidth}
        \centering
        \lstinputlisting[
            nolol,
            language=Kotlin,
            linewidth=\linewidth,
            basicstyle=\scriptsize\ttfamily,
%        caption={Entrypoint},
            label={lst:agents}
        ]{listings/jakta+alchemist/agents.kt}
    \end{minipage}
    \caption{
        The agent specifications (left) are completely platform-agnostic and reusable,
        some glue code (right) wires the logics with the underlying execution platform.
    }
    \label{fig:code}
\end{figure}


To investigate the effect of the mapping granularity on the system's behavior, experiments are conducted with the \ac{AMA}, \ac{ACLI}, and \ac{ACLP} granularities.
%
To do so, \ac{AMA} is used as baseline,
letting the entire \ac{MAS} run a full cycle every simulated second.
%
Then the baseline is compared with \ac{ACLI} and \ac{ACLP},
for which each agent is modeled with an execution frequency $f$
following a Weibull distribution with mean $f$ and deviation $f\cdot\tau$ modeling the \emph{relative drift} in the internal clock of different devices.
%
Additionally, for the \ac{ACLP} granularity deliberation and action delays are modeled,
associating each phase with an exponential distribution with rate $\lambda = f$:
faster agents (larger $f$ values) have less delay.
%
Every experiment is repeated $100$ times with a different random seed, changing
the initial positions of the followers
and the distribution in time of the events for the \ac{ACLI} and \ac{ACLP}.

\begin{figure}[tb]
    \centering
    \includegraphics[width=\linewidth]{figures/jakta+alchemist/error_over_time_flattened.pdf}
    \caption{
        Average error with time for different granularities, with \ac{ACLI} and \ac{ACLP} running at $f=1Hz$ and $f=2Hz$.
        Different charts show different values of relative drift $\tau$.
        Coloured shadows represent $\pm 1\sigma$ over multiple runs.
    }
    \label{subfig:err_time}
\end{figure}
%
% \begin{figure}
%     \centering
%     \includegraphics[width=\linewidth]{figures/jakta+alchemist/error_over_variances.pdf}
%     \caption{
%         Mean squared distance error with relative drift ($\tau$), measured for different frequencies for \ac{ACLI} and \ac{ACLP}.
%         Coloured shadows represent $\pm 1\sigma$.
%     }
%     \label{subfig:err_drift}
% \end{figure}
\Cref{subfig:err_time} shows the error on the followers position with respect to the ideal formation over time as the mean square distance of all followers \acp{UAV}.
As expected given the simplistic implementation of the agent's logic, the \ac{AMA} granularity appears to be the most stable, converging quickly to a low error.
%
Differently from \ac{AMA}, both \ac{ACLI} and \ac{ACLP} instead, show a degradation in performance at low frequencies and higher relative drifts.
%
This is due to the fact that the implementation assumed implicit synchronization among agents and virtually no-delay in the perception-action loop (which is the case in \ac{AMA}), but fail to adapt fast enough when the execution is asynchronous and delayed, similarly to real-world deployments.

This showcase demonstrates that selecting fine-grained granularities for mapping the \ac{BDI} control loop into \ac{DES} events is necessary to accurately simulate real-world deployments, thus supporting the argument that the \ac{BDI} framework should expose the ability to finely decouple the execution of individual phases of the control loop from the concurrency model.

%=======================================================
\section{BDI Agents in Hypermedia Environments}
%=======================================================

As discussed in \Cref{sec:back:mas:web}, the Web is increasingly being seen as a \emph{hypermedia environment} where autonomous agents can operate and interact with resources through \ac{REST} interactions, and by consuming semantic descriptions of resources and services.

Even more recently,
with the advent of \ac{LLM}-based \emph{Agentic AI}~\cite{Acharya_Kuppan_Divya_2025}
the creation of \ac{LLM}-driven agents that interact with Web APIs~\cite{10.5555/3692070.3692540}
(or directly with Websites~\cite{10.5555/3692070.3694608})
has gained significant attention.
%
However,
despite being promising,
these approaches
do not make structured knowledge representation obsolete~\cite{pan2024tkde},
and often trade the controllability offered by traditional agent-programming paradigms
for more guarantees in terms of correctness, and completeness.

Arguably,
Web-integrated agents developed with cognitive architectures,
such as \ac{BDI} agents,
would retain controllability and predictability:
they could directly exploit hypermedia to discover new resources and actions,
and use Semantic Web technologies like \ac{RDF} and \ac{OWL}
to act intelligently without compromising on quality.
%
However,
it can be argued that
the integration of \ac{BDI} agents with the Web
is hindered by a conceptual and technological gap,
which limits developers in creating agents that need to interact with (Semantic) hypermedia.
%
More precisely:
\begin{itemize}
  \item\label{gap:logic}
  \ac{BDI} agents are historically tied to \ac{LP}
  %-- e.g., with the popular \agentspeak{} semantic~\cite{DBLP:conf/maamaw/Rao96} --
  whereas the Semantic Web is grounded on description logic,
  and although the two paradigms are theoretically compatible,
  their practical implementations interoperate poorly,
  increasing integration cost significantly;
  % The different technological choices used to concretely implement them add cognitive load to developers working on the integration of the two worlds (e.g., converting \ac{OWL} and \ac{RDF} triples in Prolog-like formulas);

  \item\label{gap:open-world}
  \ac{BDI} agents are typically based on the \ac{PRS} architecture~\cite{georgeff1987reactive}
  which relies on pre-defined plans and does not natively support discovering new actions at runtime,
  a necessary feature to interact proficiently with hypermedia environments.
\end{itemize}

In \cite{burattini2025gap}, a detailed analysis of these gap is presented, reflecting on the nuances of different models and concrete syntaxes used for logic representation, query semantics and inference mechanisms.
%
The analysis results in the definition of a set of requirements that can guide future research on bridging the gap between \ac{BDI} agents and hypermedia environments.
%
For a deeper integration of \ac{BDI} agents with semantic hypermedia environments, the following requirements should be addressed:
\begin{enumerate}[label=\textbf{(R\arabic*)}]
  \item direct manipulation of \ac{RDF} and \ac{OWL} triples in the agent's belief base;
  \label{req:direct}

  \item ontological inference for deliberation (e.g., plan selection and execution);
  \label{req:reasoning}

  \item support for querying the belief base via \acs{SPARQL};
  \label{req:query}

  \item ability to exploit affordances discovered in the environment to dynamically adapt the agents' plans.
  \label{req:actions}
\end{enumerate}

%--------------------------------------------------------------
\subsection{A Generalized BDI Engine}
%--------------------------------------------------------------

Towards addressing \ref{req:direct}, \ref{req:reasoning}, and \ref{req:query}, \cite{burattini2025gap} proposed the development of a generalized \ac{BDI} engine that can be specialized to work with different belief, goal, plan representations and reasoning mechanisms. 
%
A similar approach has been proposed in~\cite{novak2006atal}, 
in which authors discuss the idea of a modular \ac{BDI} architecture,
to make it independent of the logic representation and reasoning mechanisms,
although not in the context of hypermedia.
%
Sharing the core modularity idea, the proposal of a generalized \ac{BDI} interpreter encapsulating agents reasoning cycle,
while decoupling the specific technology used for knowledge representation and manipulation would allow for tailoring the reasoning mechanisms to application-specific needs.
%
In this way,
beliefs
can flexibly support different formats depending on the domain at hand
and be adapted to work directly with e.g., \ac{RDF} triples, to JSON, YAML, and other Web standards.

Similarly, the fundamental operations performed by a \ac{BDI} agent (e.g., plan selection, belief update, goal adoption), could be implemented using customized mechanisms that leverage the specific semantics of the adopted representation.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/generalize_bdi.pdf}
    \caption{
        The generalized \ac{BDI} engine architecture.
        The core \ac{BDI} reasoning cycle is decoupled from the specific implementations of beliefs, goals, plans, and reasoning mechanisms.
        This allows for specializing the engine to work with different representations and logics.
    }
    \label{fig:generalized-bdi-engine}
\end{figure}


\Cref{fig:generalized-bdi-engine} schematically illustrates the architecture of the proposed \ac{BDI} engine showing three layers:
\begin{itemize}
  \item \textbf{generalized \ac{BDI} reasoning layer},
  where the agent's deliberation process is implemented as a reasoning cycle,
  yet agnostic to how beliefs are represented and manipulated.
  %
  This is where
  agents' intentions are maintained
  and updated as agents perceive,
  decide what to do,
  and finally act.
  %
  Any operation involving beliefs, or plan selection, should rely on some \emph{abstract} \acs{API},
  to be implemented by the next layer.
  %
  \item \textbf{concrete specification layer},
  where the aforementioned \acs{API} is implemented to provide concrete operations on the belief base and plan library.
  %
  This layer acts as an adapter between the generalized \ac{BDI} reasoner
  and the specific knowledge representation technologies of choice.
  %
  Lastly,
    \item \textbf{application layer},
  where actual goals, plans, and interactions of a \ac{MAS} are defined
  to tackle some specific use case.
\end{itemize}

This architectural blueprint is a starting point, to which the \jakta{} framework (\Cref{sec:mas:engineering:jakta}) is intended to evolve, to better support the integration of \ac{BDI} agents with other kinds of systems, including hypermedia environments. 

%-------------------------------------------------------
\subsection{Embodiment for Agents on the Web}
%-------------------------------------------------------

When considering open, dynamic, and large-scale systems where different agents may join and leave a shared environment at any time, the ability to \emph{discover information about other agents} becomes a crucial factor for enabling interaction.
%
One way to enable the discovery of agents in such open systems is to equip them with \emph{bodies} that are reified in the shared environment.
Such bodies may also permit agents to communicate indirectly through reciprocal observation of their actions, facilitate contextual interaction, and support accountability mechanisms through the observability of visible agent behavior---all of which is enabled through embodiment.
%
The body itself becomes an indicator of an agent's presence, offering means to perceive its (observable) state and actions---and possibly even to ascribe goals to the agent~\cite{castelfranchi2012abscribingminds}.

Software agents are typically defined as \emph{situated} (\Cref{chap:back:MAS}), but not necessarily \emph{embodied} as the two properties are not dependent on each other when considering virtual environments.
%
On the Web, being \emph{situated} implies agents can browse the Web by discovering and following links from page to page. However, the agents are not \emph{embodied}: Multiple agents browsing the same website are typically unaware of one other, as there is no representation of the other agents currently \emph{on} the same page.
%
This does not preclude \textit{designing} websites that support embodiment---and this can be witnessed regularly, for instance, in collaborative document editors. However, such support must be designed and implemented explicitly into the website.

Following the proposal of \ac{hMAS} to make all significant entities in a \ac{MAS} represented within the hypermedia environment~\cite{Ciortea_Boissier_Ricci_2019}, it is possible to design an agent body as a Web resource that other agents can discover and interact with. 
%
A step in this direction is taken in~\cite{Zimmermann2023}, which motivates the need for agents' situatedness and embodiment in open hypermedia environments and illustrates a potential solution based on the Solid specifications~\cite{Solid_0.9.0:21}. The authors outline several requirements for agent embodiment in decentralized hypermedia systems, but they do not provide a conceptual model for agent bodies as first-class abstractions which can guide the design of digital embodiment in \ac{hMAS} and other kinds of virtual environments.

\cartago{} (\Cref{sec:back:mas:aose}) which is an inspiration for \ac{hMAS} provides an implementation of agent bodies as \emph{artifacts} that are automatically assigned to agents when they join a \emph{workspace}~\cite{Ricci_Piunti_Viroli_Omicini_2009}.
%
The artifact serves as a proxy to the agent in the shared environment, enabling \cartago{} to support heterogeneous agents in the same environment.

Following these ideas, \cite{embodiment2025} proposes a conceptual notion of \emph{agent body} for \ac{hMAS} based on the following set of features:
\begin{itemize}
    \item \textbf{Discoverability}: bodies enable agents to discover one another in an environment and optionally identify the corresponding agent associated to it. 
    \item \textbf{Communication Through Behavior}: bodies enable implicit communication between agents through their observable behavior, by showing the actions being performed by the agent.
    \item \textbf{Accountability}: bodies support accountability mechanisms by making the agent's actions and state observable.
    \item \textbf{Situation-Dependent Interaction}: bodies facilitate interaction by exposing contextually relevant information about the agent as well as affordances to interact with it.
\end{itemize}

To support such desired features, the agent body is hence defined as:
\begin{quote}
\emph{
A body is an artifact reifying and identifying an agent in an environment. The body situates the agent, transparently mediating its actions and allowing the agent to perceive in a timely fashion.
The body allows others to observe the owner agent and its behavior, and to perceive agent-specific affordances to interact with it.
}
\end{quote}

This definition captures the fundamental properties of an agent body in virtual environments, emphasizing its role in reifying the agent (\textbf{concreteness}), identifying it (\textbf{identifiability}), implicitly mediate actions (\textbf{transparency}), routing perceptions from the environment (\textbf{timely perception}) and allowing other agents to observe the agent's behavior through it (\textbf{focusability})~\cite{embodiment2025}.

\begin{code}
\captionof{listing}{A description of agent {\tt alice} and its body artifact.}
\label{lst:agent-description}
\begin{minted}{turtle}
@base <http://localhost:8080/> .
@prefix hmas: <https://purl.org/hmas/> .
@prefix td: <https://www.w3.org/2019/wot/td#> .
@prefix jacamo: <https://purl.org/hmas/jacamo/> .

<workspaces/production/artifacts/alice/#artifact> a td:Thing, hmas:Artifact, jacamo:Body;
  hmas:isContainedIn <workspaces/production/#workspace>;
  jacamo:isBodyOf <workspaces/production/agents/alice/#agent>;
  td:hasActionAffordance [ a td:ActionAffordance, jacamo:Focus;
    td:name "focus";
    td:hasForm [ htv:methodName "POST";
      hctl:hasTarget <workspaces/production/artifacts/alice/focus>;
      hctl:forContentType "application/json";
      hctl:hasOperationType td:invokeAction ];
    td:hasInputSchema [ a js:ObjectSchema;
      js:properties [ a js:StringSchema;
        js:propertyName "callbackURI"]
    ]].

<workspaces/production/artifacts/alice/#agent> a hmas:Agent .
<workspaces/production/#workspace> a hmas:Workspace .
\end{minted}
\end{code}

\Cref{lst:agent-description} shows an example of implementation of an agent body as an artifact within an hypermedia environment exposed by the Yggdrasil platform~\cite{Ciortea_Boissier_Ricci_2019}.
%
Through \ac{RDF} triples, the agent \texttt{alice} is described as an instance of \texttt{hmas:Agent} (with the \ac{hMAS} ontology~\cite{hmas-core}), and its body is shown as currently contained in a workspace, situating the agent in the hypermedia environment.
%
The body artifact is also identified as an instance of \ac{WoT} \emph{Thing}~\cite{wot-td}, and exposes an action affordance \texttt{focus} that other agents can invoke to observe \texttt{alice}'s body (e.g., to monitor its behavior).

The definition of agent bodies for \ac{hMAS} opens up interesting research directions towards better supporting societies of agents operating in hypermedia environments. 
%
\ref{req:actions} assumes particular importance in this context, as agents would not only discover actions exposed by passive \emph{artifacts} in the environment, but possibly also from other agents through their bodies. 

%-------------------------------------------------------
\subsection{Enhancing BDI Agent Adaptability}
%-------------------------------------------------------

This section briefly reports contributions in the area of enhancing the adaptability of \ac{BDI} agents towards addressing \ref{req:actions}.
%
Although not directly focused on hypermedia environments, the proposed approaches can be extended to such contexts to improve agent adaptability in open and dynamic environments.
This follows the ideas presented in Section~5.4 of \cite{Boissier_Ciortea_Harth_Ricci_Vachtsevanou_2023}, which discusses the enhancement of agents through a set of reusable strategies that can support their exploration of open environments such as the Web.

Along this line of research,
\cite{Ciatto_Aguzzi_Battistini_Baiardi_Burattini_Ricci_2025} proposes an approach to leverage the generative capabilities of \acp{LLM} to generate plans on-the-fly, based on the current context and goals of the agent.
%
Although still in preliminary stages, this approach can significantly enhance the adaptability of \ac{BDI} agents in dynamic environments, as they can generate new plans when existing ones are not suitable for the current situation.
%
In hypermedia environments, where agents might be programmed to expect specific structures or resources, the ability to generate plans dynamically can help them adapt to unexpected changes.
%
\ac{LLM} can also be used to interpret the semantics of Web resources and map relevant information to the agent's beliefs and goals, possibly guiding the adaptation process.
%
The exploitation of \ac{GenAI} techniques for the design of agents is an open research direction, to which \ac{BDI} agents can contribute by providing a structured framework of cognitive abstractions that support the design and interpretation of autonomous behavior~\cite{DBLP:conf/atal/Ricci0ZBC24}.


A different approach is taken in \cite{DBLP:journals/aamas/HubnerBRM25}, 
where a proposal for enabling \ac{BDI} agents to forecast their behavior in a simulated environment before acting in the real deployment context is presented as a way to detect future issues and adapt accordingly by refining ordering of options.
%
\cite{wesaac} further explores this idea when considering multiple future-oriented \ac{BDI} agents, noticing how, without the exchange of information, agents may still end up in conflicting situations as they adapt their behavior based on their individual forecasts which may miss the effects of other agents' actions.

This approach can be particularly useful in hypermedia environments,
where the dynamics of the environment and the presence of other agents can lead to unexpected situations.
%
In this context, \acp{DT} can actually help agents to simulate their actions in a controlled environment, letting agents play out their plans on a simulation of the \ac{PA} first to detect potential issues and react accordingly.
%
This opens up interesting future research directions on the interplay of adaptable \ac{BDI} agents and \acp{DTE}~\cite{DBLP:conf/eumas/Burattini23}.


%=======================================================
\section{Explainability in \acs{BDI} Agents}
%=======================================================

Explainability emerged in recent years as an important desired property for artificial intelligence (AI) based systems~\cite{xu2019explainable}.
%
While the term is more prominently employed to describe the process of extracting human-understandable explanations from Machine Learning models to improve the users' level of trust or allow developers to gain insights into the learned parameters~\cite{barredoarrietaExplainable2020}, the field of AI is much broader and includes many other kinds of systems that may benefit from the ability to generate such explanations.

Among these AI-based systems, \ac{MAS} play a prominent role. 
In this context, explainability mainly concerns the ability to motivate the agents' decision-making process and enable users to validate whether the choices conform to expected behavior.

As discussed in \Cref{sec:back:h40:explainable-ai}, this is an essential requirement for the development of intelligent applications in safety-critical domains such as healthcare. 
%
Accordingly, this section explores how explainability mechanisms can be integrated into \ac{BDI} agents, to enhance their transparency.

%-------------------------------------------------------
\subsection{Multi-Level Explainability}
%-------------------------------------------------------

High-level cognitive models and architectures such as \ac{BDI} support explainability \textit{by design}~\cite{Harbers10,Broekens10}, in principle.
%
% Existing approaches
%
This has been clearly recognized in literature by different approaches in the last two decades, including works about exploiting explainability for debugging BDI agents~\cite{10.1007/978-3-642-32729-2_3,Winikoff2017why}, and validating BDI agent's behavior~\cite{winikoff2022badcoffee}. 

The approach proposed in \cite{DBLP:journals/aamas/YanBHR25} follows the intuition of these related works, recognizing that explainability in \ac{BDI} agents can be addressed at different levels of abstraction, each targeting different stakeholders and use cases.
This range from developers working at the implementation level---i.e., using a specific agent programming language---to designers and engineers who may want to abstract from details of the specific technology and focus more on the architectural level, to finally the domain experts and end-users,  who focus on the functional and non-functional requirements of the system as a whole, viewing it as a ``black-box''.

The proposed \emph{multi-level explainability framework} identifies three levels of explainability for \ac{BDI} agents:
\begin{itemize}
    \item \textbf{Implementation Level}: explanations at this level target \textbf{software engineers and developers}, supporting them in the phases of debugging and testing agent behavior. It focuses on the specific implementation details of the agent and is specific to the agent programming language used (in the prototype, \jason{}~\cite{Bordini_Hübner_Wooldridge_2007})
    \item \textbf{Design Level}: explanations at this level target \textbf{designers and architects} as well as developers of the system that want to abstract from the low-level implementation details -- concerning specific e.g. agent programming languages or technologies -- and focus more on the behavior of the agents at the design level.
    %
    This level is a good abstraction for designers and architects who want to comprehend the current system's behavior, interact with other stakeholders and developers or formulate new requirements for improving the system.
    \item \textbf{Domain Level}: the top level, abstracting from how the system has been designed and focusing more on what functionalities the system is meant to provide to stakeholders -- i.e. functional and non-functional requirements -- dealing with domain-specific knowledge and insights.
    %
    This level is meant to be useful both for \textbf{end-users}, to understand and explain the system's behavior as a whole while using it, and for \textbf{software engineers}, to validate the system given the specification and requirements defined during the analysis stage of the software engineering process.
\end{itemize}

The proposed framework relies on a process that converts system logs into natural language \emph{narratives} that can be used to derive explanations for \ac{BDI} agents at the different levels of abstraction, as illustrated in \Cref{fig:explainability-process}.

\begin{figure}[tb]
        \centering
        \includegraphics[width=0.8\textwidth]{figures/multi-explain/process-new.pdf}
        \caption{The explainability process converting system logs into narratives that can be used to derive explanations for \ac{BDI} agents.}
        \label{fig:explainability-process}
\end{figure}

\cite{DBLP:journals/aamas/YanBHR25} details how the process can be implemented in practice, identifying set of events for each level, and a mapping function from one layer to the next one.
%
This allows to generate explanations at one level, depending on the events at the lower level, thus enabling a hierarchical approach to explainability.

The resulting process is illustrated in \Cref{fig:multi-level-explainability}, showing how explanations at each level are derived from the narratives generated at the lower level, essentially reducing the complexity of the explanation as the level of abstraction increases.
%
This is coherent with the idea that users at different levels of abstraction require different kinds of explanations, that progressively abstract from low-level implementation details.
%
The middle level is implemented using high-level cognitive constructs such as goals, plans and intentions.
%
This ideally would make it possible to use it as a common ground for different \ac{BDI} implementations, as these constructs are shared across different \ac{BDI} agent programming languages and frameworks.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/multi-explain/agent-multi-level.pdf}
    \caption{Graphical representation of the multi-level explainability framework for \ac{BDI} agents.}
    \label{fig:multi-level-explainability}
\end{figure}

The framework has been prototypically implemented and evaluated in the context of a \ac{BDI} agent developed with \jason{}~\cite{Bordini_Hübner_Wooldridge_2007}. Logs of the agent's execution are collected by extending the \jason{} interpreter, and then they can be processed by an external system to generate explanations at the implementation and design level. 
%
The domain level remains an open research direction, as it requires the injection of additional knowledge such as functional and non-functional requirements of the system, to be able to generate explanations that are coherent with the domain at hand.


%-------------------------------------------------------
\subsection{Inter-Agent Explainability}
%-------------------------------------------------------

In addition to generating explanations for human stakeholders, \ac{BDI} agents may also benefit from the ability to explain their behavior to other agents in the system.
%
This is particularly relevant in scenarios where agents need to collaborate or coordinate their actions to achieve common goals, or possibly learn from each other. 

\cite{beaumont2025engineering} explores this idea by proposing implementation strategies for building blocks that enable the support of inter-agent explainability in \ac{BDI} agents.
%
The base building block is to extend the agent architecture with a dedicated \emph{explanation store}: a special purpose memory in which agents can store and retrieve \emph{explanatory content} to generate explanations.
%
This is different from the belief base, which is typically used to store \emph{present} knowledge, extending the agent's memory with a dedicated component for storing \emph{past} knowledge and action traces.

The proposed strategies are the following: 
\begin{itemize}
    \item \textbf{Inter-agent explanation protocol:} Define interaction protocols (following the proposal by Ciatto et al.\ \cite{ciatto2023general}) to enable agents to request and exchange explanations via messages, supporting interoperability and structured dialogue.
    \item \textbf{Implicit and explicit addition mechanisms:} Support both automatic (implicit) and developer-driven (explicit) ways to add \emph{explanatory content} to the explanation store, allowing greater control and flexibility.
    \item \textbf{Runtime state identifiers and inspection:} Provide language-level identifiers and inspection mechanisms for agent runtime state (e.g., plans, intentions), enabling agents to extract and relate relevant information for explanations.
    \item \textbf{Configurable retrieval and generation:} Allow developers to configure how explanatory content is retrieved and explanations are generated (e.g., via rules, ML, or logic), adapting to different application needs.
    \item \textbf{Uniform machine-understandable representations:} Use structured, ontology-based formats for explanations to ensure machine interpretability and interoperability among heterogeneous agents.
\end{itemize}

Exploring inter-agent explainability opens up interesting research directions for \ac{BDI} agents, especially in the context of open and dynamic environments such as hypermedia systems, where agents may need to interact with unknown agents and justify their actions to others.



%=======================================================
\section{Final Remarks}
%=======================================================


This chapter presents different contributions in the area of engineering \ac{BDI} agents and \ac{MAS}, 
focusing on addressing challenges that would make agents easier to develop and integrate with external systems, with a specific focus on hypermedia-based systems, linking to the research activities on \ac{hMAS}~\cite{Ciortea_Boissier_Ricci_2019} and the \ac{HWoDT} proposed in \Cref{chap:dte:hwodt}.
%
As a complementary perspective to the development of agents, the chapter also explores the role of testing through simulation and explainability mechanisms to enhance the reliability and transparency of \ac{BDI} agents, towards their adoption in real-world applications such as the automation of healthcare processes.
%
These contributions go towards the long-term vision of combining \ac{BDI} agents with \acp{DTE} to create intelligent, adaptive, and explainable systems that can operate in complex environments, leveraging the rich semantic models and the separation of concerns in the interaction with the physical environment provided by \acp{DT} to support the agents' reasoning and decision-making processes.

\paragraph{\ref{rq:5} How to make the development of \ac{BDI} agents more accessible and easier to integrate with external systems such as \ac{DT}?}

\ac{BDI} agents are arguably not as accessible as other programming paradigms. 
This is not necessarily due to the complexity of the \ac{BDI} model itself---which can be rather considered intuitive due to the cognitive abstractions it provides---but rather to the gap of current \ac{BDI} frameworks that originated in the context of \ac{AI} research rather than mainstream software engineering.
%
\ac{BDI} agent development can be made more accessible through the conception of new frameworks that better align with modern software engineering practices, \emph{blending} abstractions with other mainstream paradigms and decouple the \ac{BDI} reasoning cycle both from concurrency models and knowledge representation technologies, letting developers choose the most suitable ones for their application.
%
Improved reliability of \ac{BDI} agents can be achieved through simulation-based testing. Explainability features can further support the debugging process, and enhance user trust in autonomous systems. 
%
Fundamental research on extending the capabilities of \ac{BDI} agents to adapt to dynamic environments is also necessary to make them more resilient and autonomous in real-world deployment scenarios.  